    description

ring0的内核（堆栈：内核堆栈）

时钟中断<刷新cs>（没有特权级变化，继续使用内核堆栈，保存返回地址A）
内核线程都保存在内核堆栈中（!!!）
调度算法（内核堆栈）
设置tss指向ring1线程的进程表1
iret（ring1线程切换）<刷新cs>（ring1堆栈使用）

时钟中断<刷新cs>（特权级变化，使用内核堆栈）
保存状态到进程表1中（<由于中断前tss指向ring1线程的进程表1>）
调度算法（执行内核线程）
设置tss指向ring0内核线程的进程表0（没用!!!）
iretd（内核堆栈的地址A丢失，不行）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
综上，个人认为yu的堆栈式方法有缺陷，不能返回内核ring0进程，只能在中断程序ring0和ring1的线程之间来回切换。
linux好像在中断处理函数中有一个参数，呼叫时所带的参数cpl是从被中断程序的段选择符（保存在堆栈中的cs段寄存器值<无论特权级变化与否，cs处于当前堆栈指针附近>）中取得当前代码特权级cpl。
如果cpl=0，表示进程执行在内核态时被中断。do_timer()立即推出。

可解决方法：
时钟中断发生，判断rpl=0，则移动堆栈段指针ss和esp到上一个进程表，然后手动改变堆栈指针指向上一个进程表，push即可。
当下一个进程的rpl=0时，指向进程表，pop寄存器，pop ss和esp，iretd即可。
或者
时钟中断发生，判断rpl=0，则移动堆栈段指针ss和esp到上一个进程表，直接push寄存器到内核栈即可。
当下一个进程的rpl=0时，指向进程表，pop ss和esp，从内核堆栈pop寄存器，iretd即可。
第二种方法把进程表当作了 有特权级变化时的tss（ring1->ring0）和堆栈（ring0->ring1）。即切换堆栈的场所。
这两种方法都是先恢复堆栈，从堆栈中恢复cs和eip的。

8086多任务（无特权级变换）
~~~~~~~~~~~~~~~~~~~~~~~~~
ring0内核，产生时钟中断
――――――――内核栈―――――――――――
因时钟中断保存的内核进程的cs和eip
――――――――――――――――――――――
先保存堆栈指针到进程表0，然后更改堆栈指向进程表0，保存寄存器。
调度结果，ring0进程1执行，从进程表1恢复进程1的寄存器（第一次执行，进程表预先设置好了），堆栈指针指向进程1的堆栈（如果进程1第一次执行，要在进程1堆栈中写入进程1的执行地址作为返回地址），iretd。时钟中断
――――――进程1的堆栈―――――――――――
因时钟中断保存的进程1的cs和eip
――――――――――――――――――――――
保存堆栈指针到进程表1，然后更改堆栈指向进程表1，保存寄存器。
调度结果，内核进程执行，从进程表0中恢复寄存器，堆栈指针指向内核堆栈，iretd。

cs和eip放在公用的堆栈中是不行的。不同进程的出入栈会互相干扰。
而intel的cpu的指令系统要想改变cs和eip，就要从堆栈中来恢复改变。
所以，在目标堆栈中放入进程执行地址。
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
arm则不同，arm可以先修改堆栈指针，然后直接修改pc。
如：mov pc, lr 等同于 跳转或函数调用/返回。
80386提供了不必从目标堆栈恢复进程执行地址的方式，tss方式。
而特权级变化时，同样不必使用目标堆栈恢复方式。
ring0->ring1:从当前堆栈（ring0堆栈，不是目标堆栈）恢复目标进程的执行地址。
ring1->ring0:从tss中恢复。

80386多任务
~~~~~~~~~~~
内核进程开中断后马上进行任务切换，此时任务1执行，始终中断，此时堆栈不换，仍然使用任务1的堆栈，
时钟中断任务调度，jmp tss，保存状态到任务1的tss。当任务1下次执行的时候，进行中断返回即可继续执行。

如果任务1的特权级=3，时钟中断时，进行堆栈切换，这时使用的是任务1的tss中的0级堆栈，.......，再次执行任务1时，从时钟中断末执行，直至中断返回，又一次堆栈切换，从0级堆栈返回时，又一次堆栈切换，转到3级堆栈。
